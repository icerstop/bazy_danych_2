1. CREATE TABLE DziennikOperacji (
    id_operacji NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    data_operacji TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    typ_operacji VARCHAR2(10),
    nazwa_tabeli VARCHAR2(50),
    liczba_rekordow NUMBER
);

CREATE OR REPLACE TRIGGER LogujOperacje
AFTER INSERT OR UPDATE OR DELETE ON Zespoly
DECLARE
    v_liczba_rekordow NUMBER;
BEGIN
    SELECT COUNT(*) INTO v_liczba_rekordow FROM Zespoly;
    IF INSERTING THEN
        INSERT INTO DziennikOperacji (typ_operacji, nazwa_tabeli, liczba_rekordow)
        VALUES ('INSERT', 'Zespoly', v_liczba_rekordow);
    ELSIF UPDATING THEN
        INSERT INTO DziennikOperacji (typ_operacji, nazwa_tabeli, liczba_rekordow)
        VALUES ('UPDATE', 'Zespoly', v_liczba_rekordow);
    ELSIF DELETING THEN
        INSERT INTO DziennikOperacji (typ_operacji, nazwa_tabeli, liczba_rekordow)
        VALUES ('DELETE', 'Zespoly', v_liczba_rekordow);
    END IF;
END;
/

INSERT INTO Zespoly (id_zesp, nazwa, adres) VALUES (1, 'Algorytmy', 'Budynek A');

2. CREATE OR REPLACE TRIGGER PokazPlace
BEFORE UPDATE OF placa_pod ON Pracownicy
FOR EACH ROW
WHEN (NVL(OLD.placa_pod, -1) <> NVL(NEW.placa_pod, -1))
BEGIN
    DBMS_OUTPUT.PUT_LINE('Pracownik ' || :OLD.nazwisko);
    IF :OLD.placa_pod IS NULL THEN
        DBMS_OUTPUT.PUT_LINE('Płaca przed modyfikacją: NULL');
    ELSE
        DBMS_OUTPUT.PUT_LINE('Płaca przed modyfikacją: ' || :OLD.placa_pod);
    END IF;

    IF :NEW.placa_pod IS NULL THEN
        DBMS_OUTPUT.PUT_LINE('Płaca po modyfikacji: NULL');
    ELSE
        DBMS_OUTPUT.PUT_LINE('Płaca po modyfikacji: ' || :NEW.placa_pod);
    END IF;
END;

3. CREATE OR REPLACE TRIGGER UzupelnijPlace
BEFORE INSERT ON Pracownicy
FOR EACH ROW
BEGIN
    IF :NEW.etat IS NOT NULL THEN
        SELECT MIN(placa_min)
        INTO :NEW.placa_pod
        FROM Etaty
        WHERE nazwa_etatu = :NEW.etat
        AND :NEW.placa_pod IS NULL;
    END IF;
    IF :NEW.placa_dod IS NULL THEN
        :NEW.placa_dod := 0;
    END IF;
END;
/

4. drop sequence seq_zespoly;

declare
    v_max_id number;

begin
    select nvl(max(id_zesp), 0) + 1
    into v_max_id
    from zespoly;

    execute immediate 'CREATE SEQUENCE seq_zespoly ' ||
                        'START WITH ' || v_max_id ||
                        ' INCREMENT BY 1 NOCACHE NOCYCLE';
end;
/


INSERT INTO Zespoly(nazwa, adres) VALUES('NOWY', 'brak');

5. create or replace view szefowie as 
select p.nazwisko as szef,
    count(pd.id_prac) as pracownicy
    from pracownicy p
        join pracownicy pd on pd.id_szefa = p.id_prac
    group by p.nazwisko;

create or replace trigger t_del_szef
instead of delete on szefowie
referencing old as old new as new
for each row
declare
    v_id_prac pracownicy.id_prac%type;
    v_count number;

begin
    select id_prac
    into v_id_prac
    from pracownicy
    where nazwisko = :old.szef;


    for pod in (
        select id_prac
        from pracownicy
        where id_szefa = v_id_prac 
    )
    loop
        select count(*)
        into v_count
        from pracownicy
        where id_szefa = pod.id_prac;

        if v_count > 0 then
            raise_application_error(-20001,
            'Jeden z podwładnych usuwanego pracownika (' ||pod.id_prac ||') '|| 'jest szefem innych pracowników. Usuwanie anulowane!');
        end if;
    end loop;

    delete from pracownicy
    where id_szefa = v_id_prac;

    delete from pracownicy
    where id_szefa = v_id_prac;
end;
/


SELECT * FROM Szefowie;

DELETE FROM Szefowie WHERE szef = 'MORZY';

SELECT * FROM Pracownicy WHERE id_prac = 140 OR id_szefa = 140;

select * from pracownicy

rollback;

6. ALTER TABLE Zespoly ADD liczba_pracownikow NUMBER;

UPDATE Zespoly z
SET z.liczba_pracownikow = (
  SELECT COUNT(*)
  FROM Pracownicy p
  WHERE p.id_zesp = z.id_zesp
);

CREATE OR REPLACE TRIGGER TRG_UPD_ZESP_LICZBA
AFTER INSERT OR DELETE OR UPDATE OF ID_ZESP ON Pracownicy
FOR EACH ROW
BEGIN
    IF INSERTING THEN
        UPDATE Zespoly
           SET LICZBA_PRACOWNIKOW = LICZBA_PRACOWNIKOW + 1
         WHERE ID_ZESP = :NEW.ID_ZESP;
    END IF;

    IF DELETING THEN
        UPDATE Zespoly
           SET LICZBA_PRACOWNIKOW = LICZBA_PRACOWNIKOW - 1
         WHERE ID_ZESP = :OLD.ID_ZESP;
    END IF;

    IF UPDATING THEN
        IF :OLD.ID_ZESP <> :NEW.ID_ZESP THEN
            UPDATE Zespoly
               SET LICZBA_PRACOWNIKOW = LICZBA_PRACOWNIKOW - 1
             WHERE ID_ZESP = :OLD.ID_ZESP;

            UPDATE Zespoly
               SET LICZBA_PRACOWNIKOW = LICZBA_PRACOWNIKOW + 1
             WHERE ID_ZESP = :NEW.ID_ZESP;
        END IF;
    END IF;
END;
/


SELECT * FROM Zespoly;

INSERT INTO Pracownicy (id_prac, nazwisko, id_zesp, id_szefa)
VALUES (300, 'NOWY PRACOWNIK', 40, 120);


INSERT INTO Pracownicy (id_prac, nazwisko, id_zesp, id_szefa)
VALUES (350, 'NEW EMPLOYEE', 40, 120);

SELECT * FROM Zespoly;

UPDATE Pracownicy
   SET id_zesp = 10
 WHERE id_zesp = 30;

7. ALTER TABLE PRACOWNICY DROP CONSTRAINT FK_ID_SZEFA;

ALTER TABLE PRACOWNICY
ADD CONSTRAINT FK_ID_SZEFA
FOREIGN KEY (ID_SZEFA)
REFERENCES PRACOWNICY(ID_PRAC)
ON DELETE CASCADE;

SET SERVEROUTPUT ON

CREATE OR REPLACE TRIGGER Usun_Prac
AFTER DELETE ON PRACOWNICY
FOR EACH ROW
BEGIN
    DBMS_OUTPUT.PUT_LINE('Usuwany pracownik: ' || :OLD.NAZWISKO);
END;
/

SET SERVEROUTPUT ON

DELETE FROM PRACOWNICY
 WHERE NAZWISKO = 'MORZY';

 ROLLBACK;

 DROP TRIGGER Usun_Prac;

 CREATE OR REPLACE TRIGGER Usun_Prac
BEFORE DELETE ON PRACOWNICY
FOR EACH ROW
BEGIN
    DBMS_OUTPUT.PUT_LINE('Usuwany pracownik (BEFORE): ' || :OLD.NAZWISKO);
END;
/

SET SERVEROUTPUT ON;

DELETE FROM PRACOWNICY
 WHERE NAZWISKO = 'MORZY';
 
ROLLBACK;

8. ALTER TABLE PRACOWNICY DISABLE ALL TRIGGERS;

SELECT TRIGGER_NAME, STATUS
FROM USER_TRIGGERS
WHERE TABLE_NAME = 'PRACOWNICY';

SET SERVEROUTPUT ON;

INSERT INTO PRACOWNICY (ID_PRAC, NAZWISKO, ID_ZESP, ID_SZEFA)
VALUES (999, 'TEST', 10, NULL);

ALTER TABLE PRACOWNICY ENABLE ALL TRIGGERS;


INSERT INTO PRACOWNICY (ID_PRAC, NAZWISKO, ID_ZESP, ID_SZEFA)
VALUES (997, 'TEST2', 10, NULL);

9. BEGIN
    FOR w IN (SELECT trigger_name FROM user_triggers) LOOP
        EXECUTE IMMEDIATE 'DROP TRIGGER ' || w.trigger_name;
    END LOOP;
END;
/



